import { Data, Encodeable, EncodeContext, EncodeMedium } from '@simonbackx/simple-encoding';
import { SimpleError } from '@simonbackx/simple-errors';
import { AuditLogReplacement, AuditLogReplacementType } from '../AuditLogReplacement.js';

export class File implements Encodeable {
    id: string;

    /// Path to the server
    server: string;

    name: string | null;

    /**
     * Set by the uploader, so not trustworthy - can be used as a hint.
     */
    contentType: string | null;

    /// Path relative to the server
    path: string;

    /// file size in bytes
    size: number;

    /// private or not?
    isPrivate: boolean = false;

    /// signed url if it is a private file
    /// only filled if you have access to this file and when it has a valid signature
    signedUrl: string | null = null;

    /**
     * A signature that proves that this file was generated by the server and is trusted. Without a valid signature,
     * the backend won't return a signedUrl for accessing the file.
     */
    signature: string | null = null;

    /**
     * When using public/private keys inside the check functions, you can also only implement the check method
     * to verify signatures received from the backend.
     */
    static verifyFile: ((file: File) => Promise<boolean>) | null = null;
    static signFile: ((file: File) => Promise<void>) | null = null;
    static getWithSignedUrl: ((file: File) => Promise<File | null>) | null = null;

    constructor(data: {
        id: string;
        server: string;
        path: string;
        size: number;
        name?: string | null;
        isPrivate?: boolean;
        signedUrl?: string | null;
        signature?: string | null;
        contentType?: string | null;
    }) {
        this.id = data.id;
        this.server = data.server;
        this.path = data.path;
        this.size = data.size;
        this.name = data.name ?? null;
        this.isPrivate = data.isPrivate ?? false;
        this.signedUrl = data.signedUrl ?? null;
        this.signature = data.signature ?? null;
        this.contentType = data.contentType ?? null;
    }

    getDiffValue() {
        return AuditLogReplacement.create({
            id: this.getPublicPath(),
            value: this.name ?? undefined,
            type: AuditLogReplacementType.File,
        });
    }

    get signPayload() {
        return 'id: ' + this.id + '\n'
            + 'server: ' + this.server + '\n'
            + 'path: ' + this.path + '\n'
            + 'size: ' + this.size.toFixed(0) + '\n'
            + 'name: ' + this.name + '\n'
            + 'isPrivate: ' + (this.isPrivate ? 'true' : 'false')
            + (this.contentType ? '\ncontentType: ' + this.contentType : '');
    }

    static get signingEnabled() {
        return !!File.signFile;
    }

    async sign() {
        if (!File.signFile) {
            return false;
        }
        await File.signFile(this);
        return true;
    }

    async verify() {
        if (!this.signature) {
            return false;
        }

        if (!File.verifyFile) {
            return false;
        }

        return await File.verifyFile(this);
    }

    async withSignedUrl() {
        if (!this.signature || !this.isPrivate) {
            return null;
        }

        if (!File.getWithSignedUrl) {
            return null;
        }

        if (!await this.verify()) {
            // Never generate a signed url for an untrusted file
            return null;
        }

        return await File.getWithSignedUrl(this);
    }

    static decode(data: Data): File {
        const file = new File({
            id: data.field('id').string,
            server: data.field('server').string,
            path: data.field('path').string,
            size: data.field('size').integer,
            name: data.optionalField('name')?.string ?? null,

            isPrivate: data.optionalField('isPrivate')?.boolean ?? false,
            signedUrl: data.optionalField('signedUrl')?.string ?? null,
            signature: data.optionalField('signature')?.string ?? null,
            contentType: data.optionalField('contentType')?.string ?? null,
        });

        if (data.context.medium === EncodeMedium.Database || !file.isPrivate || !file.signature) {
            // Clear signed url that we read from the database - these won't be valid any longer
            file.signedUrl = null;
        }

        if (file.isPrivate && this.signingEnabled && (!data.context.medium || data.context.medium === EncodeMedium.Network)) {
            // A signature is required
            // Because of the sync nature of decoding, we cannot verify it here, but we need to do so when using the file
            if (!file.signature) {
                throw new SimpleError({
                    code: 'missing_signature',
                    message: 'Missing signature for private file',
                });
            }
        }

        return file;
    }

    encode(context: EncodeContext) {
        return {
            id: this.id,
            server: this.server,
            path: this.path,
            size: this.size,
            name: this.name,
            isPrivate: this.isPrivate,
            signedUrl: this.isPrivate && this.signedUrl ? this.signedUrl : undefined,
            signature: this.isPrivate ? this.signature : undefined,
            contentType: this.contentType || undefined,
        };
    }

    getPublicPath(): string {
        if (this.signedUrl && this.isPrivate) {
            return this.signedUrl;
        }
        return this.server + '/' + this.path;
    }

    static contentTypeToExtension(contentType: string): string | null {
        switch (contentType.toLocaleLowerCase()) {
            case 'image/jpeg':
            case 'image/jpg':
                return 'jpg';
            case 'image/png':
                return 'png';
            case 'image/gif':
                return 'gif';
            case 'image/webp':
                return 'webp';
            case 'image/svg+xml':
                return 'svg';
            case 'application/pdf':
                return 'pdf';
            case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
            case 'application/vnd.ms-excel':
                return 'xlsx';

            case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
            case 'application/msword':
                return 'docx';
        }

        return null;
    }

    static removeExtension(filename: string): string {
        return filename.split('.').slice(0, -1).join('.');
    }

    get icon() {
        if (!this.contentType) {
            // Try based on extension
            const extension = this.name?.split('.').pop()?.toLowerCase();
            if (extension) {
                switch (extension) {
                    case 'png':
                    case 'jpg':
                    case 'jpeg':
                    case 'gif':
                    case 'webp':
                    case 'svg':
                        return 'file-image';
                    case 'pdf':
                        return 'file-pdf color-pdf';
                    case 'xlsx':
                    case 'xls':
                        return 'file-excel color-excel';
                    case 'docx':
                    case 'doc':
                        return 'file-word color-word';
                }
            }

            return 'file';
        }

        if (this.contentType.startsWith('image/')) {
            return 'file-image';
        }

        if (this.contentType === 'application/pdf') {
            return 'file-pdf color-pdf';
        }
        if (this.contentType === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' || this.contentType === 'application/vnd.ms-excel') {
            return 'file-excel color-excel';
        }
        if (this.contentType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || this.contentType === 'application/msword') {
            return 'file-word color-word';
        }

        return 'file';
    }
}
